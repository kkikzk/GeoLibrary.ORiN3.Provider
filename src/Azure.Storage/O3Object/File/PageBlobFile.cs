using Azure;
using Azure.Storage.Blobs.Models;
using Design.ORiN3.Common.V1.AutoGenerated;
using Design.ORiN3.Provider.V1;
using GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.File.Base;
using GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.Interface;
using ORiN3.Provider.Core;
using ORiN3.Provider.Core.OptionAnalyzer;
using ORiN3.Provider.Core.OptionAnalyzer.Attributes;
using ORiN3.Provider.Core.ProviderException;
using System.Text.Json;

namespace GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.File;

internal class PageBlobFile : BlobFileBase<IPageBlobClient, PageBlobFile.PageBlobFileOption>
{
    private ETag? _eTag;
    private long _position;
    private IPageBlobClient? _blobClient;

    internal class PageBlobFileOption : BlobFileOption
    {
        [Optional]
        [JsonElementName("Create New If Not Exists")]
        public OptionValue<bool> CreateNewIfNotExists { get; set; } = new();

        [Optional]
        [JsonElementName("Length")]
        [NumericRange(0L, long.MaxValue)]
        public OptionValue<long> Length { get; set; } = new();
    }

    protected override IPageBlobClient GetClient(BlobContainerClientEx client, string blobPath)
    {
        return client.GetPageBlobClient(blobPath);
    }

    protected override Task OnInitializingAsync(JsonElement option, bool needVersionCheck, object? fromParent, CancellationToken token)
    {
        return base.OnInitializingAsync(option, needVersionCheck, fromParent, token);
    }

    protected override PageBlobFileOption AnalyzeOption(JsonElement option)
    {
        var optionManager = new OptionManager<PageBlobFileOption>(option);
        return optionManager.Analyze();
    }

    protected async override Task OnOpeningAsync(JsonElement rootElement, IDictionary<string, object?> argument, CancellationToken token)
    {
        // await base.OnOpeningAsync(rootElement, argument, token).ConfigureAwait(false); <= do not call.

        try
        {
            var connectionString = ConnectionString.Create(this);
            var containerName = ArgumentHelper.GetArgument(_analyzedResult!.ContainerName, nameof(_analyzedResult.ContainerName));
            var containerClient = new BlobContainerClientEx(connectionString.ToString(), containerName);
            _blobClient = GetClient(containerClient, _analyzedResult!.BlobPath.Value);
            var exists = await _blobClient.ExistsAsync(token).ConfigureAwait(false);
            if (!exists.Value)
            {
                if (_analyzedResult.CreateNewIfNotExists.IsDefined && _analyzedResult.CreateNewIfNotExists.Value)
                {
                    if (!_analyzedResult.Length.IsDefined)
                    {
                        throw new ProviderCoreException($"The \"Create New If Not Exists\" flag was set to true, but the Blob size (Length) was not specified.", (ResultCode)AzureStorageProviderResultCode.InvalidBlobCreationOption);
                    }
                    var length = _analyzedResult.Length.Value;
                    await _blobClient.CreateAsync(length, token).ConfigureAwait(false);
                    ORiN3ProviderLogger.LogTrace($"Page Blob Created. [name={_analyzedResult!.BlobPath.Value}, length={length}]");
                }
                else
                {
                    throw new ProviderCoreException($"The specified blob does not exist. [name={_analyzedResult!.BlobPath.Value}]", (ResultCode)AzureStorageProviderResultCode.BlobNotFound);
                }
            }

            _position = 0L;
            _properties = (await _blobClient.GetPropertiesAsync(token).ConfigureAwait(false)).Value;
            _eTag = _properties.ETag;
        }
        catch (RequestFailedException ex)
        {
            var blobPath = (_analyzedResult != null) ? _analyzedResult!.BlobPath.Value : "unknown";
            var errorCode = string.IsNullOrEmpty(ex.ErrorCode) ? "empty" : ex.ErrorCode;
            var errorMessage = $"An error occurred during Azure operation. [Blob Path={blobPath}, Error Code={errorCode}, HTTP Status={ex.Status}, Message={ex.Message}]\r---\r{ex.StackTrace}]";
            throw new ProviderCoreException((ResultCode)AzureStorageProviderResultCode.AzureApiExecutionError, errorMessage, ex);
        }
    }

    protected override Task OnClosingAsync(IDictionary<string, object?> argument, CancellationToken token)
    {
        // return base.OnClosingAsync(argument, token);

        _properties = null;
        _eTag = null;
        _position = 0;
        _blobClient = null;
        return Task.CompletedTask;
    }

    protected async override Task<int> OnReadingAsync(Memory<byte> buffer, CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }

        try
        {
            var range = new HttpRange(_position, buffer.Length);
            var conditions = new BlobRequestConditions { IfMatch = _eTag };
            var response = await _blobClient!.DownloadAsync(range, conditions, token).ConfigureAwait(false);
            var result = await response.Value.Content.ReadAsync(buffer, token).ConfigureAwait(false);
            return result;
        }
        catch (RequestFailedException ex) when (ex.Status == 412)
        {
            // ETagが一致しない（＝データが他で変更された）
            throw;
        }
    }

    protected async override Task OnWritingAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }

        var pageStart = _position / 512L * 512L;
        var pageEnd = (_position + buffer.Length + 511L) / 512L * 512L;
        var pageLength = pageEnd - pageStart;

        var conditions = new BlobRequestConditions { IfMatch = _eTag };
        var content = await _blobClient!.DownloadAsync(new HttpRange(pageStart, pageLength), conditions, token).ConfigureAwait(false);
        var pageBuffer = new byte[pageLength];
        using (var contentValue = content.Value)
        {
            await contentValue.Content.ReadAsync(pageBuffer, cancellationToken: token).ConfigureAwait(false);
        }
        buffer.CopyTo(pageBuffer.AsMemory((int)(_position - pageStart)));

        using var stream = new MemoryStream(pageBuffer);
        try
        {
            var uploadConditions = new PageBlobUploadPagesOptions { Conditions = new PageBlobRequestConditions() { IfMatch = _eTag } };
            await _blobClient!.UploadPagesAsync(stream, pageStart, uploadConditions, token).ConfigureAwait(false);
        }
        catch (RequestFailedException ex) when (ex.Status == 412)
        {
            throw;
        }
    }

    protected override Task<bool> OnCanReadAsync(CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(true);
    }

    protected override Task<bool> OnCanWriteAsync(CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(true);
    }

    protected override Task<long> OnGettingLengthAsync(CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(_properties!.ContentLength);
    }

    protected override Task OnSettingLengthAsync(long value, CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }
        return base.OnSettingLengthAsync(value, token); // TBD
    }

    protected async override Task<long> OnSeekingAsync(long offset, ORiN3FileSeekOrigin origin, CancellationToken token = default)
    {
        if (_properties == null)
        {
            throw new ProviderCoreException(ResultCode.FileNotOpened);
        }

        if (origin == ORiN3FileSeekOrigin.Begin)
        {
            _position = offset;
        }
        else if (origin == ORiN3FileSeekOrigin.Current)
        {
            _position += offset;
        }
        else if (origin == ORiN3FileSeekOrigin.End)
        {
            var length = await OnGettingLengthAsync(token).ConfigureAwait(false);
            _position = length + offset;
        }
        return _position;
    }
}
