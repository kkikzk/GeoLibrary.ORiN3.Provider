using Azure;
using Azure.Storage.Blobs.Models;
using Colda.CommonUtilities.IO;
using Design.ORiN3.Common.V1.AutoGenerated;
using Design.ORiN3.Provider.V1;
using GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.Interface;
using GeoLibrary.ORiN3.Provider.BaseLib;
using ORiN3.Provider.Core;
using ORiN3.Provider.Core.OptionAnalyzer;
using ORiN3.Provider.Core.OptionAnalyzer.Attributes;
using ORiN3.Provider.Core.ProviderException;
using System.Text.Json;
using FileBase = ORiN3.Provider.Core.Abstract.FileBase;

namespace GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.File.Base;

internal class BlobFileOption
{
    [JsonElementName("Container Name")]
    public OptionValue<string> ContainerName { get; set; } = new();

    [JsonElementName("Blob Path")]
    public OptionValue<string> BlobPath { get; set; } = new();
}

internal abstract class BlobFileBase<TClient, SOption> : FileBase, ConnectionString.IHasNameAndKey
    where TClient : IBlobBaseClient
    where SOption : BlobFileOption, new()
{
    protected SOption? _analyzedResult;
    private DirectoryInfo? _workingDir;
    private FileInfo? _tempFile;
    private FileStream? _stream;
    protected BlobProperties? _properties;

    public string AccountName { private set; get; } = string.Empty;
    public string AccountKey { private set; get; } = string.Empty;
    public bool UseHttps { private set; get; } = true;
    public string EndpointSuffix { private set; get; } = "core.windows.net";
    public string ProxyUri { private set; get; } = string.Empty;

    protected override Task OnInitializingAsync(JsonElement option, bool needVersionCheck, object? fromParent, CancellationToken token)
    {
        var temp = (Array)fromParent!;
        var nameAndKey = temp.GetValue(0) as ConnectionString.IHasNameAndKey;
        AccountName = nameAndKey!.AccountName;
        AccountKey = nameAndKey!.AccountKey;
        UseHttps = nameAndKey!.UseHttps;
        EndpointSuffix = nameAndKey!.EndpointSuffix;
        ProxyUri = nameAndKey!.ProxyUri;
        _workingDir = temp.GetValue(1) as DirectoryInfo;

        _analyzedResult = AnalyzeOption(option);

        return base.OnInitializingAsync(option, needVersionCheck, fromParent, token);
    }

    protected virtual SOption AnalyzeOption(JsonElement option)
    {
        var optionManager = new OptionManager<SOption>(option);
        return optionManager.Analyze();
    }

    protected async override Task OnOpeningAsync(JsonElement rootElement, IDictionary<string, object?> argument, CancellationToken token)
    {
        try
        {
            await base.OnOpeningAsync(rootElement, argument, token).ConfigureAwait(false);

            var tempFileName = Guid.NewGuid().ToString();
            _tempFile = new FileInfo(Path.Combine(_workingDir!.FullName, tempFileName));

            var connectionString = ConnectionString.Create(this);
            var containerName = ArgumentHelper.GetArgument(_analyzedResult!.ContainerName, nameof(_analyzedResult.ContainerName));
            var containerClient = new BlobContainerClientEx(connectionString.ToString(), ProxyUri, containerName);
            var blobClient = GetClient(containerClient, _analyzedResult!.BlobPath.Value);

            var exists = await blobClient.ExistsAsync(token).ConfigureAwait(false);
            if (!exists.Value)
            {
                throw new GeoLibraryProviderException<AzureStorageProviderResultCode>(
                    AzureStorageProviderResultCode.BlobNotFound, $"The specified blob does not exist. [name={_analyzedResult!.BlobPath.Value}]");
            }

            //await blobClient.SetHttpHeadersAsync(new BlobHttpHeaders { CacheControl = "no-cache" }, cancellationToken: token);

            _properties = (await blobClient.GetPropertiesAsync(token).ConfigureAwait(false)).Value;
            _ = await blobClient.DownloadToAsync(_tempFile.FullName, token).ConfigureAwait(false);
            _stream = new FileStream(_tempFile.FullName, FileMode.Open, FileAccess.Read);
        }
        catch (RequestFailedException ex)
        {
            var blobPath = (_analyzedResult != null) ? _analyzedResult!.BlobPath.Value : "unknown";
            var errorCode = string.IsNullOrEmpty(ex.ErrorCode) ? "empty" : ex.ErrorCode;
            var errorMessage = $"An error occurred during Azure operation. [Blob Path={blobPath}, Error Code={errorCode}, HTTP Status={ex.Status}, Message={ex.Message}]\r---\r{ex.StackTrace}]";
            throw new GeoLibraryProviderException<AzureStorageProviderResultCode>(AzureStorageProviderResultCode.AzureApiExecutionError, errorMessage, ex);
        }
    }

    protected abstract TClient GetClient(BlobContainerClientEx client, string blobPath);

    protected override Task<long> OnGettingLengthAsync(CancellationToken token = default)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(_stream!.Length);
    }

    protected override Task<long> OnSeekingAsync(long offset, ORiN3FileSeekOrigin origin, CancellationToken _ = default)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(_stream!.Seek(offset, (SeekOrigin)origin));
    }

    protected override Task<bool> OnCanReadAsync(CancellationToken token = default)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(true);
    }

    protected override Task<bool> OnCanWriteAsync(CancellationToken token = default)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(false);
    }

    protected async override Task<int> OnReadingAsync(Memory<byte> buffer, CancellationToken token = default)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return await _stream.ReadAsync(buffer, token).ConfigureAwait(false);
    }

    protected override Task OnWritingAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        throw new ProviderCoreException($"Blob is not writable. [Type={GetType().FullName}]", (ResultCode)AzureStorageProviderResultCode.BlobNotWritable);
    }

    protected override async Task OnClosingAsync(IDictionary<string, object?> argument, CancellationToken token)
    {
        _properties = null;

        if (_stream != null)
        {
            try
            {
                _stream.Close();
                _stream.Dispose();
                _stream = null;
            }
            catch
            {
                // nothing to do.
            }
        }

        if (_tempFile != null && _tempFile.Exists)
        {
            try
            {
                await _tempFile.SafeDeleteAsync().ConfigureAwait(false);
            }
            catch
            {
                // nothing to do.
            }
            _tempFile.Delete();
            _tempFile = null;
        }

        await base.OnClosingAsync(argument, token).ConfigureAwait(false);
    }

    protected override async Task<IDictionary<string, object?>> OnExecutingAsync(string commandName, IDictionary<string, object?> argument, CancellationToken token = default)
    {
        return commandName switch
        {
            "GetProperties" => await GetPropertiesAsync(argument, token).ConfigureAwait(false),
            _ => await base.OnExecutingAsync(commandName, argument, token).ConfigureAwait(false),
        };
    }

    protected virtual Task<IDictionary<string, object?>> GetPropertiesAsync(IDictionary<string, object?> _1, CancellationToken _2)
    {
        if (_stream == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }

        ORiN3ProviderLogger.LogTrace($"{nameof(GetPropertiesAsync)} called.");
        var result = new Dictionary<string, object?>
        {
            [ParamNames.Result] = ResponseCode.Unknown,
            [ParamNames.BlobPath] = string.Empty,
            [ParamNames.ContentLength] = 0L,
            [ParamNames.ContentType] = string.Empty,
            [ParamNames.LastModified] = DateTime.MinValue,
            [ParamNames.CreatedOn] = DateTime.MinValue,
            [ParamNames.Archived] = false,
            [ParamNames.ServerEncrypted] = false,
            [ParamNames.ETag] = string.Empty,
            [ParamNames.CustomMetadata] = string.Empty,
            [ParamNames.ErrorMessage] = string.Empty,
            [ParamNames.StackTrace] = string.Empty,
        };

        try
        {
            result[ParamNames.Result] = ResponseCode.Success;
            result[ParamNames.BlobPath] = _analyzedResult!.BlobPath.Value;
            result[ParamNames.ContentLength] = _properties!.ContentLength;
            result[ParamNames.ContentType] = _properties!.ContentType;
            result[ParamNames.LastModified] = _properties!.LastModified.UtcDateTime;
            result[ParamNames.CreatedOn] = _properties!.CreatedOn.UtcDateTime;
#pragma warning disable IDE0075
            result[ParamNames.Archived] = _properties!.AccessTier == null ? false : _properties!.AccessTier == AccessTier.Archive;
#pragma warning restore IDE0075
            result[ParamNames.ServerEncrypted] = _properties!.IsServerEncrypted;
            result[ParamNames.ETag] = _properties!.ETag.ToString();
            result[ParamNames.CustomMetadata] = _properties!.Metadata == null ? null : JsonSerializer.Serialize(_properties!.Metadata);
            return Task.FromResult<IDictionary<string, object?>>(result);
        }
        catch (Exception e)
        {
            result[ParamNames.Result] = ResponseCode.OtherError;
            result[ParamNames.ErrorMessage] = e.Message;
            result[ParamNames.StackTrace] = e.StackTrace;
            return Task.FromResult<IDictionary<string, object?>>(result);
        }
    }
}
