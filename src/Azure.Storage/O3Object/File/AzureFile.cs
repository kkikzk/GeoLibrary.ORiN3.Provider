using Azure;
using Azure.Storage.Files.Shares.Models;
using Design.ORiN3.Common.V1.AutoGenerated;
using Design.ORiN3.Provider.V1;
using GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.Interface;
using GeoLibrary.ORiN3.Provider.BaseLib;
using GeoLibrary.ORiN3.Provider.BaseLib.IO;
using ORiN3.Provider.Core;
using ORiN3.Provider.Core.Abstract;
using ORiN3.Provider.Core.OptionAnalyzer;
using ORiN3.Provider.Core.OptionAnalyzer.Attributes;
using System.Text.Json;

namespace GeoLibrary.ORiN3.Provider.Azure.Storage.O3Object.File;

internal class AzureFile : FileBase, ConnectionString.IHasNameAndKey
{
    private AzureFileOption? _analyzedResult;
    private long _position;
    private IShareFileClient? _fileClient;
    private ShareFileProperties? _properties;
    private readonly string _leaseId = string.Empty;

    private class AzureFileOption
    {
        [JsonElementName("Share Name")]
        public OptionValue<string> ShareName { get; set; } = new();

        [JsonElementName("File Name")]
        public OptionValue<string> FileName { get; set; } = new();

        [Optional]
        [JsonElementName("Directory Name")]
        public OptionValue<string> DirectoryName { get; set; } = new();

        [Optional]
        [JsonElementName("Create New If Not Exists")]
        public OptionValue<bool> CreateNewIfNotExists { get; set; } = new();

        [Optional]
        [JsonElementName("Length")]
        [NumericRange(0L, long.MaxValue)]
        public OptionValue<long> Length { get; set; } = new();
    }

    public string AccountName { private set; get; } = string.Empty;
    public string AccountKey { private set; get; } = string.Empty;
    public bool UseHttps { private set; get; } = true;
    public string EndpointSuffix { private set; get; } = "core.windows.net";

    protected override Task OnInitializingAsync(JsonElement option, bool needVersionCheck, object? fromParent, CancellationToken token)
    {
        var temp = (Array)fromParent!;
        var nameAndKey = temp.GetValue(0) as ConnectionString.IHasNameAndKey;
        AccountName = nameAndKey!.AccountName;
        AccountKey = nameAndKey!.AccountKey;
        UseHttps = nameAndKey!.UseHttps;
        EndpointSuffix = nameAndKey!.EndpointSuffix;

        var optionManager = new OptionManager<AzureFileOption>(option);
        _analyzedResult = optionManager.Analyze();

        _position = 0;

        return base.OnInitializingAsync(option, needVersionCheck, fromParent, token);
    }

    protected async override Task OnOpeningAsync(JsonElement rootElement, IDictionary<string, object?> argument, CancellationToken token)
    {
        try
        {
            await base.OnOpeningAsync(rootElement, argument, token).ConfigureAwait(false);

            var connectionString = ConnectionString.Create(this);
            var shareClient = new ShareClientEx(connectionString.ToString(), _analyzedResult!.ShareName.Value);
            _ = await shareClient.CreateIfNotExistsAsync(token).ConfigureAwait(false);

            var dirClient = shareClient.GetRootDirectoryClient();
            if (_analyzedResult!.DirectoryName.IsDefined && 0 < _analyzedResult.DirectoryName.Value.Length)
            {
                foreach (var dir in _analyzedResult!.DirectoryName.Value.Split('/'))
                {
                    dirClient = dirClient.GetSubdirectoryClient(dir);
                    await dirClient.CreateIfNotExistsAsync(token).ConfigureAwait(false);
                }
            }
            _fileClient = dirClient.GetFileClient(_analyzedResult!.FileName.Value);

            var exists = await _fileClient.ExistsAsync(token).ConfigureAwait(false);
            if (!exists.Value)
            {
                if (_analyzedResult.CreateNewIfNotExists.IsDefined && _analyzedResult.CreateNewIfNotExists.Value)
                {
                    if (!_analyzedResult.Length.IsDefined)
                    {
                        throw new GeoLibraryProviderException<AzureStorageProviderResultCode>(
                            AzureStorageProviderResultCode.InvalidCreationOption, $"The \"Create New If Not Exists\" flag was set to true, but the file size (Length) was not specified.");
                    }
                    var length = _analyzedResult.Length.Value;
                    await _fileClient.CreateAsync(length, new ShareFileRequestConditions(), token).ConfigureAwait(false);
                    ORiN3ProviderLogger.LogTrace($"Fileb Created. [name={_analyzedResult!.FileName.Value}, length={length}]");
                }
                else
                {
                    throw new GeoLibraryProviderException<AzureStorageProviderResultCode>(
                        AzureStorageProviderResultCode.BlobNotFound, $"The specified blob does not exist. [path={_analyzedResult!.FileName.Value}]");
                }
            }

            _properties = (await _fileClient.GetPropertiesAsync(new ShareFileRequestConditions(), token).ConfigureAwait(false)).Value;
        }
        catch (RequestFailedException ex)
        {
            var fileName = (_analyzedResult != null) ? _analyzedResult!.FileName.Value : "unknown";
            var dirName = (_analyzedResult != null) ? (0 < _analyzedResult.DirectoryName.Value.Length ? _analyzedResult!.DirectoryName.Value : "empty") : "unknown";
            var errorCode = string.IsNullOrEmpty(ex.ErrorCode) ? "empty" : ex.ErrorCode;
            var errorMessage = $"An error occurred during Azure operation. [File Name={fileName}, Directory Name={dirName}, Error Code={errorCode}, HTTP Status={ex.Status}, Message={ex.Message}]\r---\r{ex.StackTrace}]";
            throw new GeoLibraryProviderException<AzureStorageProviderResultCode>(AzureStorageProviderResultCode.AzureApiExecutionError, errorMessage, ex);
        }
    }

    protected async override Task<long> OnGettingLengthAsync(CancellationToken token = default)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        var properties = await _fileClient!.GetPropertiesAsync(new ShareFileRequestConditions(), token).ConfigureAwait(false);
        return properties.Value.ContentLength;
    }

    protected override Task<bool> OnCanReadAsync(CancellationToken token = default)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(true);
    }

    protected override Task<bool> OnCanWriteAsync(CancellationToken token = default)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }
        return Task.FromResult(true);
    }

    protected async override Task<int> OnReadingAsync(Memory<byte> buffer, CancellationToken token = default)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }

        var remaining = _properties!.ContentLength - _position;
        if (remaining <= 0)
        {
            return 0; // EOF
        }

        var readLength = (int)Math.Min(buffer.Length, remaining);
        var range = new HttpRange(_position, readLength);
        var conditions = new ShareFileRequestConditions() { LeaseId = _leaseId };
        var options = _leaseId != null ? new ShareFileDownloadOptions() { Range = range, Conditions = conditions, } : new ShareFileDownloadOptions() { Range = range };
        using var response = (await _fileClient.DownloadAsync(options, token).ConfigureAwait(false)).Value;
        var bytesRead = await response.Content.ReadAsync(buffer, token).ConfigureAwait(false);
        _position += bytesRead;
        return bytesRead;
    }

    protected async override Task OnWritingAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }

        var range = new HttpRange(_position, buffer.Length);
        var conditions = new ShareFileRequestConditions() { LeaseId = _leaseId };
        var options = _leaseId != null ? new ShareFileUploadRangeOptions() { Conditions = conditions, } : new ShareFileUploadRangeOptions();
        using var stream = new ReadOnlyMemoryStream(buffer);
        await _fileClient!.UploadRangeAsync(range, stream, options: options, token).ConfigureAwait(false);
        _position += buffer.Length;
    }

    protected async override Task<long> OnSeekingAsync(long offset, ORiN3FileSeekOrigin origin, CancellationToken token = default)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }

        if (origin == ORiN3FileSeekOrigin.Begin)
        {
            _position = offset;
        }
        else if (origin == ORiN3FileSeekOrigin.Current)
        {
            _position += offset;
        }
        else if (origin == ORiN3FileSeekOrigin.End)
        {
            var length = await OnGettingLengthAsync(token).ConfigureAwait(false);
            _position = length + offset;
        }
        return _position;
    }

    protected Task<IDictionary<string, object?>> GetPropertiesAsync(IDictionary<string, object?> _1, CancellationToken _2)
    {
        if (_fileClient == null)
        {
            throw new GeoLibraryProviderException(ResultCode.FileNotOpened);
        }

        ORiN3ProviderLogger.LogTrace($"{nameof(GetPropertiesAsync)} called.");
        var result = new Dictionary<string, object?>
        {
            [ParamNames.Result] = ResponseCode.Unknown,
            [ParamNames.FileName] = string.Empty,
            [ParamNames.DirectoryName] = string.Empty,
            [ParamNames.ContentLength] = 0L,
            [ParamNames.ContentType] = string.Empty,
            [ParamNames.LastModified] = DateTime.MinValue,
            [ParamNames.CreatedOn] = DateTime.MinValue,
            [ParamNames.ServerEncrypted] = false,
            [ParamNames.ETag] = string.Empty,
            [ParamNames.CustomMetadata] = string.Empty,
            [ParamNames.ErrorMessage] = string.Empty,
            [ParamNames.StackTrace] = string.Empty,
        };

        try
        {
            result[ParamNames.Result] = ResponseCode.Success;
            result[ParamNames.FileName] = _analyzedResult!.FileName.Value;
            result[ParamNames.DirectoryName] = _analyzedResult!.DirectoryName.Value;
            result[ParamNames.ContentLength] = _properties!.ContentLength;
            result[ParamNames.ContentType] = _properties!.ContentType;
            result[ParamNames.LastModified] = _properties!.LastModified.UtcDateTime;
            if (_properties!.SmbProperties.FileChangedOn != null)
            {
                result[ParamNames.CreatedOn] = ((DateTimeOffset)_properties!.SmbProperties.FileChangedOn).UtcDateTime;
            }
            result[ParamNames.ServerEncrypted] = _properties!.IsServerEncrypted;
            result[ParamNames.ETag] = _properties!.ETag.ToString();
            result[ParamNames.CustomMetadata] = _properties!.Metadata == null ? null : JsonSerializer.Serialize(_properties!.Metadata);
            return Task.FromResult<IDictionary<string, object?>>(result);
        }
        catch (Exception e)
        {
            result[ParamNames.Result] = ResponseCode.OtherError;
            result[ParamNames.ErrorMessage] = e.Message;
            result[ParamNames.StackTrace] = e.StackTrace;
            return Task.FromResult<IDictionary<string, object?>>(result);
        }
    }
}
